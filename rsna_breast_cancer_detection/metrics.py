# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/metrics.ipynb.

# %% auto 0
__all__ = ['pF1']

# %% ../nbs/metrics.ipynb 1
import torch

import numpy as np
import pandas as pd

# %% ../nbs/metrics.ipynb 2
class pF1:
    def __init__(self):
        self._labels = torch.empty(0)
        self._predictions = torch.empty(0)
        
        self._pf = 0
        self._patient_laterality = []

    def reset(self):
        self._labels = torch.empty(0)
        self._predictions = torch.empty(0)

        self._pf = 0
        self._patient_laterality = []

    def compute(self, predictions, labels, beta=1):
        y_true_count = labels.sum()
        ctp = predictions[labels==1].sum()
        cfp = predictions[labels==0].sum()
        
        beta_squared = beta * beta
        c_precision = ctp / (ctp + cfp + 1e-4)
        c_recall = ctp / (y_true_count + 1e-4)
        
        if (c_precision > 0 and c_recall > 0):
            return ((1 + beta_squared) * (c_precision * c_recall) / (beta_squared * c_precision + c_recall + 1e-4)).item()
        
        return 0.0

    def update(self, predictions, labels, patient_lateralities, beta=1):
        self._predictions = torch.cat((self._predictions, predictions))
        self._labels = torch.cat((self._labels, labels))
        self._patient_laterality.extend(patient_lateralities)

        df = pd.DataFrame(np.column_stack([self._patient_laterality, self._predictions.numpy().tolist(), self._labels.numpy().tolist()]), columns=["id", "prediction", "label"])
        
        df["prediction"] = df["prediction"].astype(float)
        df["label"] = df["label"].astype(float)
        
        df = df.groupby("id").agg(
            label=pd.NamedAgg(column="label", aggfunc="max"),
            prediction_max=pd.NamedAgg(column="prediction", aggfunc="max"),
            prediction_mean=pd.NamedAgg(column="prediction", aggfunc="mean")).reset_index()
        
        self._pf1_max = self.compute(df["prediction_max"], df["label"], beta)
        self._pf1_mean = self.compute(df["prediction_mean"], df["label"], beta)
    
    def get_metric(self):
        return {"pF1_mean": self._pf1_mean, "pF1_max": self._pf1_max}
    
    def patient_laterality_optimization(self):
        df = pd.DataFrame(np.column_stack([self._patient_laterality, self._predictions.numpy().tolist(), self._labels.numpy().tolist()]), columns=["id", "prediction", "label"])
        
        df["prediction"] = df["prediction"].astype(float)
        df["label"] = df["label"].astype(float)
        
        df = df.groupby("id").agg(
            label=pd.NamedAgg(column="label", aggfunc="max"),
            prediction_max=pd.NamedAgg(column="prediction", aggfunc="max"),
            prediction_mean=pd.NamedAgg(column="prediction", aggfunc="mean")).reset_index()

        all_metrics_max = []
        all_metrics_mean = []
        
        thresholds = np.arange(0, 1.01, 0.01)
        
        for threshold in thresholds: 
            all_metrics_max.append(self.compute(df["prediction_max"].values > threshold, df["label"].values))
            all_metrics_mean.append(self.compute(df["prediction_mean"].values > threshold, df["label"].values))
        
        return {
            "pF1_max_bin": max(all_metrics_max),
            "th_max": thresholds[np.argmax(all_metrics_max)],
            "pF1_mean_bin": max(all_metrics_mean), 
            "th_mean": thresholds[np.argmax(all_metrics_mean)]}
