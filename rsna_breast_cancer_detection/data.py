# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/data.ipynb.

# %% auto 0
__all__ = ['prepere_multi_view_df', 'RSNADataset', 'RSNAMultiViewDataset']

# %% ../nbs/data.ipynb 1
import random
import torch
import cv2
import os

import pandas as pd
import numpy as np

from torch.utils.data.sampler import WeightedRandomSampler
from typing import Iterator, Sequence
from torch.utils.data import Dataset
from .utils import merge_dicts

# %% ../nbs/data.ipynb 2
def prepere_multi_view_df(df):
    df = df.copy()
    
    df = df[df["view"].isin(("MLO", "CC"))]
    df = df.groupby(["patient_id", "laterality", "view"]).agg(
        cancer=pd.NamedAgg(column="cancer", aggfunc="max"),
        image_ids=pd.NamedAgg(column="image_id", aggfunc=list),
        age=pd.NamedAgg(column="age", aggfunc="max"),
        implant=pd.NamedAgg(column="implant", aggfunc="max"),
        fold=pd.NamedAgg(column="fold", aggfunc="max")
    )

    df.reset_index(level=2, inplace=True)
    df["image_ids"] = np.where(df["view"] == "CC", df["image_ids"].apply(lambda x: {"MLO": x}), df["image_ids"].apply(lambda x: {"CC": x}))

    df = df.groupby(["patient_id", "laterality"]).agg(
        cancer=pd.NamedAgg(column="cancer", aggfunc="max"),
        image_ids=pd.NamedAgg(column="image_ids", aggfunc=merge_dicts),
        age=pd.NamedAgg(column="age", aggfunc="max"),
        implant=pd.NamedAgg(column="implant", aggfunc="max"),
        fold=pd.NamedAgg(column="fold", aggfunc="max")
    ).reset_index()
    
    return df

# %% ../nbs/data.ipynb 3
class RSNADataset(Dataset):
    def __init__(self, dataset_df, transforms=None, mode="train_val", IMAGES_DIR="../data/images"):
        if mode not in ["train_val", "inference"]:
            raise ValueError("Mode should be either train_val or inference")
        
        self.mode = mode        
        self.dataset_df = dataset_df
        self.transforms = transforms
        
        self.IMAGES_DIR = IMAGES_DIR
        
    def __len__(self):
        return len(self.dataset_df)
    
    def _normalize_image(self, image):
        return image / 255.
        
    def __getitem__(self, idx):
        patient_id = str(self.dataset_df.loc[idx, "patient_id"])
        image_id = str(self.dataset_df.loc[idx, "image_id"])
        laterality = self.dataset_df.loc[idx, "laterality"]
        age_id = self.dataset_df.loc[idx, "age"]
        
        patient_laterality = f"{patient_id}_{laterality}"
        
        if self.mode == "train_val":
            label = self.dataset_df.loc[idx, "cancer"]
        
        image_path = os.path.join(self.IMAGES_DIR, f"{patient_id}_{image_id}.png")
        image = cv2.imread(image_path, 0)

        if self.transforms is not None:
            image = self.transforms(image=image)
        
        image = self._normalize_image(image)
        
        return {
            "image": torch.tensor(image, dtype=torch.float).unsqueeze(0),#.permute(2, 0, 1),
            "patient_laterality": patient_laterality,
            "age_id": torch.tensor(age_id, dtype=torch.long),
            **({"label": torch.tensor([label], dtype=torch.long)} if self.mode == "train_val" else {})}

# %% ../nbs/data.ipynb 4
class RSNAMultiViewDataset(Dataset):
    def __init__(self, dataset_df, transforms=None, mode="train_val", IMAGES_DIR="../data/images"):
        if mode not in ["train_val", "inference"]:
            raise ValueError("Mode should be either train_val or inference")
        
        self.mode = mode        
        self.dataset_df = dataset_df
        self.transforms = transforms
        
        self.IMAGES_DIR = IMAGES_DIR
        
    def __len__(self):
        return len(self.dataset_df)
    
    def _normalize_image(self, image):
        return image / 255.
    
    def __getitem__(self, idx):
        patient_id = str(self.dataset_df.loc[idx, "patient_id"])
        image_ids = self.dataset_df.loc[idx, "image_ids"]
        laterality = self.dataset_df.loc[idx, "laterality"]
        age_id = self.dataset_df.loc[idx, "age"]
        
        patient_laterality = f"{patient_id}_{laterality}"
        
        MLO_image_path = os.path.join(self.IMAGES_DIR, f"{patient_id}_{str(random.choice(image_ids['MLO']))}.png")
        CC_image_path = os.path.join(self.IMAGES_DIR, f"{patient_id}_{str(random.choice(image_ids['CC']))}.png")
        
        MLO_image = cv2.imread(MLO_image_path, 0)
        CC_image = cv2.imread(CC_image_path, 0)
        
        if self.mode == "train_val":
            label = self.dataset_df.loc[idx, "cancer"]
        
        if self.transforms is not None:
            MLO_image = self.transforms(image=MLO_image)
            CC_image = self.transforms(image=CC_image)
        
        MLO_image = self._normalize_image(MLO_image)
        CC_image = self._normalize_image(CC_image)
        
        MLO_image_tensor = torch.tensor(MLO_image, dtype=torch.float)
        CC_image_tensor = torch.tensor(CC_image, dtype=torch.float)
        
        images = torch.stack([MLO_image_tensor, CC_image_tensor], axis=0).unsqueeze(1)
        
        return {
            "image": images,
            "patient_laterality": patient_laterality,
            "age_id": torch.tensor(age_id, dtype=torch.long),
            **({"label": torch.tensor([label], dtype=torch.long)} if self.mode == "train_val" else {})}
